import * as THREE from "three";
import Experience from "../Experience";
import ParticleMaterial from "../../Materials/ParticleGPGPUMaterial";
import { GPUComputationRenderer } from "three/examples/jsm/misc/GPUComputationRenderer.js";
import gpgpuParticleShader from "../../Materials/shaders/gpgpu/particles.glsl";
import Time from "../Utils/Time";

export default class GPGPUElement {
  constructor(model) {
    this.experience = new Experience();
    this.scene = this.experience.scene;
    this.resources = this.experience.resources;
    this.time = this.experience.time;
    this.debug = this.experience.debug;

    this.init(model);
    this.setParticles();
    this.setGPGPU();

    // this.test();
    this.setDebug();

    this.setScene(this.particles.points);
    // this.setScene(this.model.scene);
  }

  init(model) {
    this.particles = {};
    this.particles.material = new ParticleMaterial();

    this.model = model;

    const originalGeometry = this.model.scene.children[0].geometry;
    this.baseGeometry = {};
    this.baseGeometry.instance = originalGeometry.clone();

    this.baseGeometry.count =
      this.baseGeometry.instance.attributes.position.count;

    this.gpgpu = {};
    this.gpgpu.size = Math.ceil(Math.sqrt(this.baseGeometry.count));
    this.gpgpu.computation = new GPUComputationRenderer(
      this.gpgpu.size,
      this.gpgpu.size,
      this.experience.renderer.instance,
    );

    this.applyGeomTransform();

    this.baseParticlesTexture = this.gpgpu.computation.createTexture();

    this.experience.mouse.on("mousemove", () =>
      console.log("gpgpu" + "+" + "ciao"),
    );
  }

  applyGeomTransform({
    pos = [0, -20, 0],
    rot = [0, 0, 0],
    scale = [1, 1, 1],
  } = {}) {
    const m = new THREE.Matrix4().compose(
      new THREE.Vector3(...pos),
      new THREE.Quaternion().setFromEuler(new THREE.Euler(...rot)),
      new THREE.Vector3(...scale),
    );
    this.baseGeometry.instance.applyMatrix4(m);
    this.baseGeometry.instance.attributes.position.needsUpdate = true;
    this.baseGeometry.instance.computeBoundingSphere();
    this.baseGeometry.instance.computeBoundingBox?.();
    this.rotYSpeed = Math.PI * 0.25;
  }

  setParticles() {
    const image = this.baseParticlesTexture.image;
    const position = this.baseGeometry.instance.attributes.position;

    for (let i = 0; i < this.baseGeometry.count; i++) {
      const i3 = i * 3;
      const i4 = i * 4;

      image.data[i4 + 0] = position.array[i3 + 0];
      image.data[i4 + 1] = position.array[i3 + 1];
      image.data[i4 + 2] = position.array[i3 + 2];
      image.data[i4 + 3] = Math.random();
    }

    // Geometry
    this.particlesUvArray = new Float32Array(this.baseGeometry.count * 2);
    this.sizesArray = new Float32Array(this.baseGeometry.count * 1);

    for (let y = 0; y < this.gpgpu.size; y++) {
      for (let x = 0; x < this.gpgpu.size; x++) {
        const i = y * this.gpgpu.size + x;
        const i2 = i * 2;

        // Particles UV
        const uvX = (x + 0.5) / this.gpgpu.size;
        const uvY = (y + 0.5) / this.gpgpu.size;

        this.particlesUvArray[i2 + 0] = uvX;
        this.particlesUvArray[i2 + 1] = uvY;

        // Sizes
        this.sizesArray[i] = Math.random();
      }
    }

    // Points
    this.particles.geometry = new THREE.BufferGeometry();
    this.particles.geometry.setDrawRange(0, this.baseGeometry.count);

    this.setAttributes();
  }

  setGPGPU() {
    this.gpgpu.particlesVariable = this.gpgpu.computation.addVariable(
      "uParticles",
      gpgpuParticleShader,
      this.baseParticlesTexture,
    );

    this.gpgpu.computation.setVariableDependencies(
      this.gpgpu.particlesVariable,
      [this.gpgpu.particlesVariable],
    );

    this.setUniforms();

    this.gpgpu.computation.init();
  }

  setUniforms() {
    const uniforms = this.gpgpu.particlesVariable.material.uniforms;
    uniforms.uTime = new THREE.Uniform(0);
    uniforms.uDeltaTime = new THREE.Uniform(0);
    uniforms.uBasePositions = new THREE.Uniform(this.baseParticlesTexture);
    uniforms.uFlowFieldInfluence = new THREE.Uniform(0.5);
    uniforms.uFlowFieldStrenght = new THREE.Uniform(2);
    uniforms.uFlowFieldFrequency = new THREE.Uniform(0.5);
  }

  setAttributes() {
    this.particles.geometry.setAttribute(
      "aParticlesUv",
      new THREE.BufferAttribute(this.particlesUvArray, 2),
    );

    // fallback
    /* const baseColor = this.baseGeometry.instance.attributes.color;
    const colorAttr = baseColor
      ? baseColor
      : new THREE.BufferAttribute(
          new Float32Array(this.baseGeometry.count * 3).fill(1),
          3,
        ); */

    this.particles.geometry.setAttribute(
      "aColor",
      this.baseGeometry.instance.attributes.color_1,
    );

    this.particles.geometry.setAttribute(
      "aSize",
      new THREE.BufferAttribute(this.sizesArray, 1),
    );

    this.particles.points = new THREE.Points(
      this.particles.geometry,
      this.particles.material,
    );

    this.particles.points.frustumCulled = false;
  }

  setScene(object) {
    this.scene.add(object);
  }

  update() {
    const uniforms = this.gpgpu.particlesVariable.material.uniforms;
    uniforms.uTime.value = this.time.elapsed / 500;
    uniforms.uDeltaTime.value = this.time.delta / 500;

    this.gpgpu.computation.compute();

    this.particles.material.uniforms.uParticlesTexture.value =
      this.gpgpu.computation.getCurrentRenderTarget(
        this.gpgpu.particlesVariable,
      ).texture;

    this.particles.points.rotation.y =
      (this.time.elapsed / 5000) * this.rotYSpeed;
  }

  test() {
    const test = new THREE.Mesh(
      new THREE.PlaneGeometry(3, 3),
      new THREE.MeshBasicMaterial({
        map: this.gpgpu.computation.getCurrentRenderTarget(
          this.gpgpu.particlesVariable,
        ).texture,
      }),
    );

    test.position.set(3, 0, 0);
    this.setScene(test);
  }

  setDebug() {
    const ui = this?.debug?.ui;
    if (!ui) return;

    const f = (this.debug.particleGPGPUFolder ||=
      ui.addFolder?.("Particle Material"));

    f.add(
      this.gpgpu.particlesVariable.material.uniforms.uFlowFieldInfluence,
      "value",
      0.0,
      1.0,
      0.01,
    ).name("uFlowFieldInfluence");

    f.add(
      this.gpgpu.particlesVariable.material.uniforms.uFlowFieldStrenght,
      "value",
      0.0,
      10.0,
      0.01,
    ).name("uFlowFieldStrenght");

    f.add(
      this.gpgpu.particlesVariable.material.uniforms.uFlowFieldFrequency,
      "value",
      0.0,
      10.0,
      0.01,
    ).name("uFlowFieldFrequency");

    console.log(this.model.scene.children[0].geometry.attributes);
  }
}
